{"version":3,"file":"DirectoryUtils.js","sourceRoot":"","sources":["../../build-scripts-storybook/DirectoryUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fsPromises } from \"fs\";\nimport path from \"path\";\nimport glob from \"glob\";\n\nexport interface IDirectoryUtils {\n    assureDirectoryExistence(filePath: string): Promise<string | void>;\n    cleanDirectory(dir: string): Promise<void>;\n    readFiles(src: string, ignore?: string[]): Promise<string[]>;\n    writeFile(filePath: string, content: string): Promise<void>;\n    globToRelativePath(globStr: string, filePath: string): string;\n    readContent(filePath: string): Promise<string>;\n    joinPath(filePath: string): string;\n}\n\n/**\n * This class is responsible for reading and writing files to the file system.\n * It also provides some utility methods for working with file paths.\n */\nexport class DirectoryUtils implements IDirectoryUtils {\n    public async assureDirectoryExistence(\n        directory: string\n    ): Promise<string | void> {\n        if (!directory) {\n            throw new Error(\"No file path provided\");\n        }\n\n        try {\n            const dir = path.dirname(directory);\n            await fsPromises.mkdir(dir, { recursive: true });\n        } catch (error: any) {\n            // if the directory already exists, we don't need to create it\n            if (error.code !== \"EEXIST\") {\n                throw error;\n            }\n        }\n\n        return Promise.resolve();\n    }\n\n    public async cleanDirectory(directory: string): Promise<void> {\n        if (!directory) {\n            throw new Error(\"No directory path provided\");\n        }\n\n        try {\n            await fsPromises.rm(directory, { recursive: true });\n        } catch (error: any) {\n            // if the directory does not exist, we don't need to clean it\n            if (error.code !== \"ENOENT\") {\n                throw error;\n            }\n        }\n\n        return Promise.resolve();\n    }\n\n    public async readFiles(\n        src: string,\n        ignore: string[] = []\n    ): Promise<string[]> {\n        if (!src) {\n            throw new Error(\"No source path provided\");\n        }\n\n        const config = {\n            absolute: false,\n            ignore: ignore.map((pattern) => path.resolve(pattern)),\n        };\n\n        // this src is a regex, e.g. ../../../docs/**/*\n        const files = await new Promise<string[]>((resolve, reject) => {\n            const onDone = (err: Error | null, files: string[]) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(files);\n                }\n            };\n\n            glob(src, config, onDone);\n        });\n\n        return files;\n    }\n\n    public async writeFile(filePath: string, content: string): Promise<void> {\n        if (!filePath) {\n            throw new Error(\"No file path provided\");\n        }\n        if (!content) {\n            throw new Error(\"No content provided\");\n        }\n\n        await fsPromises.writeFile(filePath, content);\n    }\n\n    public globToRelativePath(globStr: string, filePath: string): string {\n        if (!filePath) {\n            throw new Error(\"No file path provided\");\n        }\n        if (!globStr) {\n            throw new Error(\"No glob string provided\");\n        }\n\n        // globStr is a regex, e.g. ../../../docs/**/*\n        // filePath is a path, e.g. ../../../docs/help/README.md\n        // the result should be ./help/README.md\n\n        // substring the globStr to get the path without the glob pattern\n        const globPath = globStr.substring(0, globStr.indexOf(\"*\"));\n        // substring the filePath to get the path without the glob pattern\n        const filePathWithoutGlob = filePath.substring(globPath.length);\n\n        return path.join(\".\", filePathWithoutGlob);\n    }\n\n    public async readContent(filePath: string): Promise<string> {\n        if (!filePath) {\n            throw new Error(\"No file path provided\");\n        }\n        const content = await fsPromises.readFile(filePath, \"utf8\");\n        return content;\n    }\n\n    public joinPath(filePath: string): string {\n        if (!filePath) {\n            throw new Error(\"No file path provided\");\n        }\n        return path.join(__dirname, filePath);\n    }\n}\n"]}